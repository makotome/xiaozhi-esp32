/*
 * bt_gamepad_server.cc
 * Otto HP Robot 蓝牙游戏手柄服务器实现
 *
 * 作者: GitHub Copilot
 * 日期: 2025-11-21
 * 版本: 1.0
 */

#include "bt_gamepad_server.h"
#include "light_mcp_controller.h"
#include <esp_log.h>
#include <cmath>
#include <cstring>

// ESP32 Classic Bluetooth & SPP headers
#include <nvs_flash.h>
#include <esp_bt.h>
#include <esp_bt_main.h>
#include <esp_bt_device.h>
#include <esp_gap_bt_api.h>
#include <esp_spp_api.h>

#define TAG "BtGamepadServer"

// SPP服务配置
static const esp_spp_sec_t sec_mask = ESP_SPP_SEC_AUTHENTICATE;
static const esp_spp_role_t role_slave = ESP_SPP_ROLE_SLAVE;

// 全局SPP句柄
static uint32_t g_spp_handle = 0;

// ==================== 静态成员初始化 ====================

BtGamepadServer *BtGamepadServer::instance_ = nullptr;

// ==================== 构造与析构 ====================

BtGamepadServer::BtGamepadServer()
    : wheel_controller_(nullptr),
      is_running_(false),
      is_connected_(false),
      move_throttler_(100),   // 移动命令 100ms 间隔
      button_throttler_(500), // 按钮命令 500ms 间隔
      current_data_(),
      dance_light_enabled_(false),
      night_light_enabled_(false)
{
    ESP_LOGI(TAG, "蓝牙游戏手柄服务器已创建");
}

BtGamepadServer::~BtGamepadServer()
{
    Stop();
    ESP_LOGI(TAG, "蓝牙游戏手柄服务器已销毁");
}

BtGamepadServer &BtGamepadServer::GetInstance()
{
    if (instance_ == nullptr)
    {
        instance_ = new BtGamepadServer();
    }
    return *instance_;
}

// ==================== 服务器控制 ====================

bool BtGamepadServer::Start()
{
    if (is_running_)
    {
        ESP_LOGW(TAG, "服务器已在运行");
        return true;
    }

    ESP_LOGI(TAG, "启动蓝牙游戏手柄服务器...");

    // 获取轮子控制器
    wheel_controller_ = GetWheelRobotController();
    if (wheel_controller_ == nullptr)
    {
        ESP_LOGE(TAG, "无法获取轮子控制器");
        return false;
    }

    // ===== 初始化蓝牙协议栈 =====

    // 1. 初始化NVS (蓝牙需要NVS存储配对信息)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // 2. 释放Classic Bluetooth和BLE的内存(我们只用Classic BT)
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));

    // 3. 初始化蓝牙控制器
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_cfg);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "蓝牙控制器初始化失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 4. 使能蓝牙控制器 (Classic Bluetooth模式)
    ret = esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "蓝牙控制器使能失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 5. 初始化Bluedroid协议栈
    ret = esp_bluedroid_init();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "Bluedroid初始化失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 6. 使能Bluedroid协议栈
    ret = esp_bluedroid_enable();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "Bluedroid使能失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 7. 注册GAP回调 (处理设备发现、连接等事件)
    ret = esp_bt_gap_register_callback(
        [](esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)
        {
            if (instance_ != nullptr)
            {
                // 转发到实例的静态回调
                BluetoothEventCallback(param);
            }
        });
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "GAP回调注册失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 8. 注册SPP回调 (处理串口数据传输)
    ret = esp_spp_register_callback(
        [](esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
        {
            if (instance_ == nullptr)
                return;

            switch (event)
            {
            case ESP_SPP_INIT_EVT:
                ESP_LOGI(TAG, "SPP已初始化");
                // 设置设备名称
                esp_bt_dev_set_device_name(DEVICE_NAME);
                // 设置可被发现和可连接
                esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
                // 启动SPP服务器
                esp_spp_start_srv(sec_mask, role_slave, 0, "Dabble_SPP");
                break;

            case ESP_SPP_SRV_OPEN_EVT:
                ESP_LOGI(TAG, "SPP连接已建立, handle=%d", param->srv_open.handle);
                g_spp_handle = param->srv_open.handle;
                instance_->SetConnected(true);
                break;

            case ESP_SPP_CLOSE_EVT:
                ESP_LOGI(TAG, "SPP连接已断开");
                instance_->SetConnected(false);
                g_spp_handle = 0;
                break;

            case ESP_SPP_DATA_IND_EVT:
                // 接收到数据 - 调用数据解析回调
                if (param->data_ind.len > 0)
                {
                    DabbleDataCallback(param->data_ind.data, param->data_ind.len);
                }
                break;

            case ESP_SPP_CONG_EVT:
                ESP_LOGD(TAG, "SPP拥塞状态: %s", param->cong.cong ? "拥塞" : "畅通");
                break;

            case ESP_SPP_WRITE_EVT:
                ESP_LOGD(TAG, "SPP写入完成, len=%d", param->write.len);
                break;

            default:
                ESP_LOGD(TAG, "SPP事件: %d", event);
                break;
            }
        });
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "SPP回调注册失败: %s", esp_err_to_name(ret));
        return false;
    }

    // 9. 初始化SPP
    ret = esp_spp_init(ESP_SPP_MODE_CB);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "SPP初始化失败: %s", esp_err_to_name(ret));
        return false;
    }

    is_running_ = true;
    ESP_LOGI(TAG, "蓝牙游戏手柄服务器已启动");
    ESP_LOGI(TAG, "设备名称: %s", DEVICE_NAME);
    ESP_LOGI(TAG, "等待 Dabble App 连接...");

    return true;
}

void BtGamepadServer::Stop()
{
    if (!is_running_)
    {
        return;
    }

    ESP_LOGI(TAG, "停止蓝牙游戏手柄服务器...");

    // 停止所有运动
    StopMovement();

    // 关闭灯光
    auto *light_controller = GetLightMcpController();
    if (light_controller != nullptr)
    {
        auto *colorful_light = light_controller->getLightController();
        if (colorful_light != nullptr)
        {
            colorful_light->stopAllEffects();
        }
    }

    // ===== 清理蓝牙资源 =====

    // 1. 关闭SPP连接
    if (g_spp_handle != 0)
    {
        esp_spp_disconnect(g_spp_handle);
        g_spp_handle = 0;
    }

    // 2. 反初始化SPP
    esp_spp_deinit();

    // 3. 禁用Bluedroid协议栈
    esp_bluedroid_disable();
    esp_bluedroid_deinit();

    // 4. 禁用蓝牙控制器
    esp_bt_controller_disable();
    esp_bt_controller_deinit();

    is_running_ = false;
    is_connected_ = false;
    dance_light_enabled_ = false;
    night_light_enabled_ = false;

    // 重置节流器
    move_throttler_.Reset();
    button_throttler_.Reset();

    ESP_LOGI(TAG, "蓝牙游戏手柄服务器已停止");
}

// ==================== 数据处理 ====================

void BtGamepadServer::ParseDabbleData(const uint8_t *data, size_t length)
{
    if (data == nullptr || length < 2)
    {
        ESP_LOGW(TAG, "无效的数据包: length=%d", length);
        return;
    }

    // Dabble协议完整实现
    // 数据包格式: [START_OF_FRAME=0xFF][MODULE_ID][FUNCTION_ID][ARG_NUM][ARG_LEN][ARG_DATA...][END_OF_FRAME=0x00]

    // 简化处理：假设接收到的是已解析的参数数据部分（2字节payload）
    // 完整协议解析应该由蓝牙层的processInput()函数完成
    // 这里我们处理GamePad模块的2字节参数数据

    if (length < 2)
    {
        ESP_LOGW(TAG, "GamePad数据包长度不足: %d", length);
        return;
    }

    DabbleGamepadData gamepad_data;

    // Byte 0 (value0) - 按钮状态
    uint8_t value0 = data[0];
    // Byte 1 (value) - 根据模式不同含义不同
    uint8_t value = data[1];

    // 解析按钮状态（所有模式通用）
    // Bit 0: START, Bit 1: SELECT, Bit 2: TRIANGLE, Bit 3: CIRCLE, Bit 4: CROSS, Bit 5: SQUARE
    uint16_t buttons = 0;
    if (value0 & (1 << 0))
        buttons |= kDabbleButtonStart; // START按钮
    if (value0 & (1 << 1))
        buttons |= kDabbleButtonSelect; // SELECT按钮
    if (value0 & (1 << 2))
        buttons |= kDabbleButton3; // TRIANGLE - 舞蹈灯光
    if (value0 & (1 << 3))
        buttons |= kDabbleButton2; // CIRCLE - 跳舞
    if (value0 & (1 << 4))
        buttons |= kDabbleButton1; // CROSS - 停止
    if (value0 & (1 << 5))
        buttons |= kDabbleButton4; // SQUARE - 夜光

    gamepad_data.buttons = buttons;

    // 根据function_id判断模式（需要从外部传入，这里先假设从第3字节获取）
    // 实际应该在蓝牙协议层解析时确定
    // GAMEPAD_DIGITAL=0x01, GAMEPAD_ANALOG=0x02, GAMEPAD_ACCL=0x03

    // 检查value的Byte1来判断是否为数字模式
    // 数字模式: Bit 0-3 表示方向键
    bool has_direction_keys = (value & 0x0F) != 0;
    rr if (has_direction_keys)
    {
        // 数字模式 (GAMEPAD_DIGITAL)
        gamepad_data.mode = kDabbleModeDigital;
        gamepad_data.up = (value & (1 << 0)) != 0;    // UP
        gamepad_data.down = (value & (1 << 1)) != 0;  // DOWN
        gamepad_data.left = (value & (1 << 2)) != 0;  // LEFT
        gamepad_data.right = (value & (1 << 3)) != 0; // RIGHT

        ESP_LOGD(TAG, "数字模式: Up=%d Down=%d Left=%d Right=%d",
                 gamepad_data.up, gamepad_data.down, gamepad_data.left, gamepad_data.right);
    }
    else
    {
        // 摇杆/加速度计模式 (GAMEPAD_ANALOG / GAMEPAD_ACCL)
        // Byte 1 编码: XXXXXYYY (5 bits angle index, 3 bits radius)
        gamepad_data.mode = kDabbleModeJoystick; // 统一处理为摇杆模式

        uint8_t angle_index = (value >> 3) & 0x1F; // 高5位 (0-23)
        uint8_t radius = value & 0x07;             // 低3位 (0-7)

        // 角度转换: angle_index * 15 = 实际角度 (0-345度)
        uint16_t angle_deg = angle_index * 15;
        gamepad_data.angle = angle_deg;
        gamepad_data.radius = radius;

        // 计算X/Y轴坐标 (-127 ~ 127)
        // X = radius * cos(angle), Y = radius * sin(angle)
        float angle_rad = angle_deg * M_PI / 180.0f;
        float x_float = radius * cosf(angle_rad);
        float y_float = radius * sinf(angle_rad);

        // 转换到 -127~127 范围
        gamepad_data.axis_x = static_cast<int8_t>(x_float * 18.14f); // 7 * 18.14 ≈ 127
        gamepad_data.axis_y = static_cast<int8_t>(y_float * 18.14f);

        ESP_LOGD(TAG, "摇杆模式: angle=%d radius=%d x=%d y=%d",
                 angle_deg, radius, gamepad_data.axis_x, gamepad_data.axis_y);
    }

    ProcessGamepadData(gamepad_data);
}

void BtGamepadServer::ProcessGamepadData(const DabbleGamepadData &data)
{
    // 保存当前数据
    current_data_ = data;

    // 优先处理按钮（包括紧急停止）
    if (data.buttons != 0)
    {
        HandleButtonPress(data.buttons);
    }

    // 根据模式处理移动
    switch (data.mode)
    {
    case kDabbleModeDigital:
        HandleDigitalMode(data);
        break;

    case kDabbleModeJoystick:
        HandleJoystickMode(data);
        break;

    case kDabbleModeAccelerometer:
        HandleAccelerometerMode(data);
        break;

    default:
        ESP_LOGW(TAG, "未知的控制模式: %d", data.mode);
        break;
    }
}

// ==================== 移动控制 - 三种模式 ====================

void BtGamepadServer::HandleDigitalMode(const DabbleGamepadData &data)
{
    // 节流检查
    if (!move_throttler_.CanExecute())
    {
        return;
    }

    const int speed = DEFAULT_DIGITAL_SPEED;

    if (data.up)
    {
        // 前进（直线）
        MoveWithOmniDirection(speed, 0.0f, true);
        ESP_LOGD(TAG, "[Digital] 前进");
    }
    else if (data.down)
    {
        // 后退（直线）
        MoveWithOmniDirection(speed, 0.0f, false);
        ESP_LOGD(TAG, "[Digital] 后退");
    }
    else if (data.left)
    {
        // 左转（前进+左满方向）
        MoveWithOmniDirection(speed, -1.0f, true);
        ESP_LOGD(TAG, "[Digital] 左转");
    }
    else if (data.right)
    {
        // 右转（前进+右满方向）
        MoveWithOmniDirection(speed, 1.0f, true);
        ESP_LOGD(TAG, "[Digital] 右转");
    }
    else
    {
        // 无方向键按下，停止
        StopMovement();
    }
}

void BtGamepadServer::HandleJoystickMode(const DabbleGamepadData &data)
{
    // 应用死区
    int8_t x = ApplyDeadzone(data.axis_x, DEADZONE_THRESHOLD);
    int8_t y = ApplyDeadzone(data.axis_y, DEADZONE_THRESHOLD);

    // 摇杆在中心，停止
    if (x == 0 && y == 0)
    {
        StopMovement();
        return;
    }

    // 节流检查
    if (!move_throttler_.CanExecute())
    {
        return;
    }

    // 计算速度和方向
    int speed = CalculateSpeedFromXY(x, y);
    float direction = CalculateDirectionFromXY(x, y);
    bool is_forward = !IsMoveBackward(y);

    // 执行万向移动
    MoveWithOmniDirection(speed, direction, is_forward);

    ESP_LOGD(TAG, "[Joystick] %s: speed=%d, direction=%.2f (x=%d, y=%d)",
             is_forward ? "前进" : "后退", speed, direction, x, y);
}

void BtGamepadServer::HandleAccelerometerMode(const DabbleGamepadData &data)
{
    // 加速度计模式复用摇杆逻辑
    // axis_x 和 axis_y 来自手机倾斜角度
    HandleJoystickMode(data);
}

// ==================== 万向移动核心 ====================

void BtGamepadServer::MoveWithOmniDirection(int speed, float direction, bool is_forward)
{
    if (wheel_controller_ == nullptr)
    {
        ESP_LOGW(TAG, "轮子控制器未初始化");
        return;
    }

    // 限制参数范围
    if (speed < 0)
        speed = 0;
    if (speed > 100)
        speed = 100;
    if (direction < -1.0f)
        direction = -1.0f;
    if (direction > 1.0f)
        direction = 1.0f;

    // 调用底层万向移动接口
    if (is_forward)
    {
        wheel_controller_->GetWheels().moveForwardWithDirection(speed, direction);
    }
    else
    {
        wheel_controller_->GetWheels().moveBackwardWithDirection(speed, direction);
    }
}

void BtGamepadServer::StopMovement()
{
    if (wheel_controller_ != nullptr)
    {
        wheel_controller_->Stop();
        ESP_LOGD(TAG, "停止移动");
    }
}

// ==================== 按钮处理 ====================

void BtGamepadServer::HandleButtonPress(uint16_t buttons)
{
    // START 按钮 - 紧急停止（无节流）
    if (buttons & kDabbleButtonStart)
    {
        OnStartPress();
        return; // START 优先级最高，立即返回
    }

    // 其他按钮需要节流
    if (!button_throttler_.CanExecute())
    {
        return;
    }

    if (buttons & kDabbleButton1)
    {
        OnButton1Press();
    }
    else if (buttons & kDabbleButton2)
    {
        OnButton2Press();
    }
    else if (buttons & kDabbleButton3)
    {
        OnButton3Press();
    }
    else if (buttons & kDabbleButton4)
    {
        OnButton4Press();
    }
}

void BtGamepadServer::OnButton1Press()
{
    ESP_LOGI(TAG, "按钮1: 停止移动");
    StopMovement();
}

void BtGamepadServer::OnButton2Press()
{
    ESP_LOGI(TAG, "按钮2: 执行跳舞");

    if (wheel_controller_ == nullptr)
    {
        return;
    }

    // 随机选择跳舞动作
    int dance_type = esp_random() % 5;

    switch (dance_type)
    {
    case 0:
        wheel_controller_->GetWheels().danceShake();
        ESP_LOGI(TAG, "执行: 摇摆舞");
        break;
    case 1:
        wheel_controller_->GetWheels().danceSpin();
        ESP_LOGI(TAG, "执行: 旋转舞");
        break;
    case 2:
        wheel_controller_->GetWheels().danceWave();
        ESP_LOGI(TAG, "执行: 波浪舞");
        break;
    case 3:
        wheel_controller_->GetWheels().danceZigzag();
        ESP_LOGI(TAG, "执行: 之字舞");
        break;
    case 4:
        wheel_controller_->GetWheels().danceMoonwalk();
        ESP_LOGI(TAG, "执行: 太空步");
        break;
    }
}

void BtGamepadServer::OnButton3Press()
{
    ESP_LOGI(TAG, "按钮3: 切换跳舞灯光");

    dance_light_enabled_ = !dance_light_enabled_;

    auto *light_controller = GetLightMcpController();
    if (light_controller != nullptr)
    {
        auto *colorful_light = light_controller->getLightController();
        if (colorful_light != nullptr)
        {
            if (dance_light_enabled_)
            {
                // 启动跳舞派对灯光效果
                colorful_light->setLightMode(ColorfulLightController::MODE_DANCE_PARTY);
                ESP_LOGI(TAG, "跳舞灯光: 开启 (五彩缤纷模式)");
            }
            else
            {
                // 停止灯光效果
                colorful_light->stopAllEffects();
                ESP_LOGI(TAG, "跳舞灯光: 关闭");
            }
        }
        else
        {
            ESP_LOGW(TAG, "彩色灯光控制器未初始化");
        }
    }
    else
    {
        ESP_LOGW(TAG, "灯光MCP控制器未初始化");
    }
}

void BtGamepadServer::OnButton4Press()
{
    ESP_LOGI(TAG, "按钮4: 切换夜光模式");

    night_light_enabled_ = !night_light_enabled_;

    auto *light_controller = GetLightMcpController();
    if (light_controller != nullptr)
    {
        auto *colorful_light = light_controller->getLightController();
        if (colorful_light != nullptr)
        {
            if (night_light_enabled_)
            {
                // 开启夜光 (纯白光模式)
                colorful_light->setLightMode(ColorfulLightController::MODE_NIGHT_LIGHT);
                ESP_LOGI(TAG, "夜光模式: 开启 (纯白光)");
            }
            else
            {
                // 关闭夜光
                colorful_light->stopAllEffects();
                ESP_LOGI(TAG, "夜光模式: 关闭");
            }
        }
        else
        {
            ESP_LOGW(TAG, "彩色灯光控制器未初始化");
        }
    }
    else
    {
        ESP_LOGW(TAG, "灯光MCP控制器未初始化");
    }
}

void BtGamepadServer::OnStartPress()
{
    ESP_LOGI(TAG, "START: 紧急停止 + 关闭所有灯光");

    // 立即停止移动
    StopMovement();

    // 关闭所有灯光
    auto *light_controller = GetLightMcpController();
    if (light_controller != nullptr)
    {
        auto *colorful_light = light_controller->getLightController();
        if (colorful_light != nullptr)
        {
            colorful_light->stopAllEffects();
            ESP_LOGI(TAG, "所有灯光效果已关闭");
        }
    }

    // 重置状态
    dance_light_enabled_ = false;
    night_light_enabled_ = false;

    // 重置节流器（允许立即再次发送命令）
    move_throttler_.Reset();
    button_throttler_.Reset();

    ESP_LOGI(TAG, "紧急停止完成");
}

// ==================== 辅助函数 ====================

int8_t BtGamepadServer::ApplyDeadzone(int8_t value, int8_t threshold)
{
    if (std::abs(value) < threshold)
    {
        return 0;
    }
    return value;
}

int BtGamepadServer::CalculateSpeedFromXY(int8_t x, int8_t y)
{
    // 使用向量长度作为速度
    float magnitude = std::sqrt(static_cast<float>(x * x + y * y));

    // 映射到 0-100 范围
    // 摇杆最大值约为 127*sqrt(2) ≈ 180
    int speed = static_cast<int>((magnitude * 100.0f) / 127.0f);

    // 限制范围
    if (speed > 100)
        speed = 100;
    if (speed < 0)
        speed = 0;

    return speed;
}

float BtGamepadServer::CalculateDirectionFromXY(int8_t x, int8_t y)
{
    // x 代表左右方向
    // -127 (左) -> -1.0
    //    0 (中) ->  0.0
    //  127 (右) ->  1.0

    float direction = static_cast<float>(x) / 127.0f;

    // 限制范围
    if (direction > 1.0f)
        direction = 1.0f;
    if (direction < -1.0f)
        direction = -1.0f;

    return direction;
}

bool BtGamepadServer::IsMoveBackward(int8_t y)
{
    // Y 轴正值为前进，负值为后退
    return y < 0;
}

// ==================== 蓝牙回调实现 ====================

void BtGamepadServer::BluetoothEventCallback(void *param)
{
    esp_bt_gap_cb_param_t *gap_param = static_cast<esp_bt_gap_cb_param_t *>(param);

    // GAP事件通常用于设备发现、认证等
    // SPP连接事件已在SPP回调中处理
    ESP_LOGD(TAG, "蓝牙GAP事件回调");
    (void)gap_param; // 避免未使用警告
}

void BtGamepadServer::DabbleDataCallback(const uint8_t *data, size_t length)
{
    // 转发到实例处理
    if (instance_ != nullptr)
    {
        instance_->ParseDabbleData(data, length);
    }
}
